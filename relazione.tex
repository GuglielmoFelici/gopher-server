\documentclass{article}

\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage[T1]{fontenc}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breakatwhitespace=true,
  tabsize=3
}

\begin{document}

\tableofcontents

\newpage

\section{Utilizzo del software}

E' possibile compilare il progetto con il comando make. La compilazione genera l'eseguibile linuxserver o winserver.exe,
e due binari aggiuntivi nel caso in cui si buildi su Windows.\\
Sono disponibili le seguenti opzioni:\\
\begin{lstlisting}
-d DIR
    Utilizza la directory DIR come root del server.
-f FILE 
    Leggi le configurazioni da FILE. 
    Per informazioni sulla struttura del file, vedere la sezione 
    3.1.1 Lettura della configurazione.
-h
    Mostra la sintassi.
-l FILE
    Logga i trasferimenti sul file FILE. 
    Default: logfile.
-m 
    Utilizza un processo per ogni client. 
    Default: no.
-p PORT
    Metti il server in ascolto sulla porta PORT. 
    Default: 7070.
-s
    (silent) - Disabilita il logging di debug. 
    Default: no.

\end{lstlisting}
Le opzioni da riga di comando hanno precedenza su quelle scritte nel file di configurazione.

\newpage

\section{Struttura del progetto}

Il progetto è strutturato con un approccio modulare gerarchico. 
Ogni modulo esegue uno specifico compito all'interno dell'applicazione, servendosi delle funzionalità
dei livelli inferiori ed esponendo funzionalità ai livelli superiori.
A livello implementativo, a ogni modulo corrisponde uno o più header e uno o più file sorgente.
I quattro moduli sono:
\begin{itemize}
    \item Server - Riceve le richieste di connessione dei client e crea nuovi thread 
    o processi per inviare le risposte. Si occupa inoltre della lettura dei file di configurazione e 
    della gestione dei segnali per l'interazione con l'utente.
    \item Protocollo - Si occupa di leggere, validare, interpretare e soddisfare la richiesta di un singolo client,
    costruendo la risposta secondo lo standard del protocollo Gopher. 
    In questo modulo avviene la lettura del file system e l'eventuale mapping 
    in memoria dei file.
    \item Logger - Gestisce il processo di logging, che ha il compito di registrare le operazioni di invio
    di file.
    \item Compatibilità - API minimale che offre diverse funzioni di supporto portabili. Espone wrapper
    di varie chiamate di sistema e altre operazioni comuni non portabili, nonché wrapper di tipi di dato.
\end{itemize} 

Per quanto il progetto sia stato impostato con struttura modulare, le sue componenti sono 
comunque interconnesse e progettate per coesistere in un'unica applicazione. 
Per questo motivo, la maggior parte delle configurazioni pertinenti a tutto il programma hanno scope globale.\\

\newpage


\section{Scelte implementative}


Ogni file espone, tramite il proprio header, funzioni utili a espletare
i compiti previsti dal modulo logico a cui il file fa riferimento. Le funzioni di ogni modulo
utilizzano come valore di ritorno delle costanti per indicare il successo o il fallimento dell'operazione (a volte
messe in OR con altre costanti per fornire ulteriori informazioni sull'esito).
\\Le funzioni esposte utilizzano i tipi definiti in datatypes.h, per astrarre dai tipi specifici utilizzati
dalla libreria Win32 o dalle funzioni POSIX. L'implementazione interna delle funzioni invece
 utilizza i tipi specifici della piattaforma, e consiste, laddove impossibile scrivere codice portabile o utilizzare solo funzioni offerte dal 
modulo di Compatibilità, di un'implementazione ad hoc per Windows e una per GNU/Linux, demandando la scelta dell'implementazione
da utilizzare al preprocessore.
Una documentazione rigorosa su ogni file, funzione e struttura, generata con Doxygen a partire dalla 
documentazione sul codice sorgente, è disponibile \href{html/index.html}{qui}. 

\subsection{Server}
Il modulo Server è implementato dall'header server.h e dal file server.c.\\
L'header dichiara la struttura server\_t, utilizzata come interfaccia:
\begin{lstlisting}
/** A struct representing an instance of a gopher server */
typedef struct {
    /** The socket of the server */
    socket_t sock;
    /** The socket address */
    struct sockaddr_in sockAddr;
    /** The port the server is listening on */
    unsigned short port;
    /** A flag indicating whether the server should spawn a process or a thread per request */
    bool multiProcess;
} server_t;
\end{lstlisting}
La maggior parte delle funzioni dichiarate dall'header richiede in input
un puntatore a una struttura server\_t, dalla quale leggere o nella quale scrivere informazioni.

\subsubsection{Lettura della configurazione}

Se viene specificato un file di configurazione con l'opzione -f, il parsing delle impostazioni avviene tramite la funzione \href{}
{readConfig}, che legge il file mediante le funzioni della libreria standard e scrive le configurazioni nella 
struttura server\_t ricevuta in input. Il file è una sequenze di righe del tipo CHIAVE = VALORE, dove sono accettate le seguenti coppie:
\begin{itemize}
    \item port = <numero di porta>
    \item multiprocess = yes/no
    \item silent = yes/no
    \item logfile = <path>
    \item root = <path>
\end{itemize}
La lettura avviene all'avvio dell'applicazione e ogniqualvolta venga ricevuto il segnale 
SIGHUP (caso Linux) o CTRL\_BREAK (caso Windows) durante il \href{}
{main loop} del server; tuttavia, nel caso in cui si ricarichino le configurazioni mentre il server è in esecuzione,
non verranno aggiornati il path di logging e la root directory del server.\\
I gestori dei segnali utilizzano le variabili booleane globali
\begin{lstlisting}
    static sig_atomic volatile updateConfig;
    static sig_atomic volatile requestShutdown;
\end{lstlisting}
che vengono lette periodicamente fintanto che il server è in ascolto. L'accesso a queste variabili è 
protetto da una CRITICAL\_SECTION nel caso Windows e dall'uso del tipo sig\_atomic\_t (wrappato in sig\_atomic per comodità)
nel caso Linux, che assicura l'accesso atomico alle variabili anche in presenza di interrupt asincroni.
Nel caso in cui la lettura delle configurazioni dovesse fallire vengono utilizzate le 
impostazioni di default, salvate in globals.h.

\subsubsection{Avvio del server}

Il server viene avviato con la funzione \href{}{runServer},
che prende in input un puntatore a una struttura server\_t opportunamente inizializzata.
La funzione attende con una select una richiesta di connessione, controllando periodicamente la ricezione
di segnali. Questa scelta è motivata dal fatto che gli eventi da console di Windows non interrompono la select.
Quando il server riceve una richiesta di connessione, genera un nuovo thread o processo (a seconda della modalità
utilizzata), il quale passa il controllo al protocollo tramite la funzione \href{}
{gopher}. Siccome il protocollo si assume la responsabilità di avviare un nuovo thread se richiesto
l'invio di un file, il thread principale di un processo che invoca la funzione gopher non termina,
se non tramite le funzioni pthread\_exit o ExitThread. Quando il server riceve una richiesta di terminazione, 
la funzione runServer ritorna con successo. Il modulo Server non si occupa di liberare le proprie risorse.

\subsection{Protocollo}

Il modulo Protocollo è implementato dall'header protocol.h, dal file protocol.c e dal file winGopherProcess.c 
nel caso in cui si compili su Windows.\\
L'header espone all'esterno, oltre a diverse costanti, una singola funzione \href{}{gopher}.
La funzione riceve l'input dal socket ricevuto fin quando non legge un CRLF;
L'input letto viene validato (poiché il selettore viene utilizzato per recuperare la risorsa
richiesta, non può contenere costrutti per la navigazione del file system, quali ./ ../ etc) e normalizzato,
per consentire una maggiore flessibilità circa le richieste accettate.
Se la connessione viene chiusa o si verifica un errore, la funzione fallisce:
il protocollo si incarica di chiudere il socket del client sia in caso di fallimento che in caso di errore.


\subsubsection{Costruzione della risposta}
La lista di file disponibili, se richiesta una directory, viene costruita utilizzando la funzione \href{}
{iterateDir}, la quale funge da interfaccia per le primitive specifiche delle piattaforme Linux e Windows,
operando in modo analogo.\\
Il carattere prefisso a ogni riga della risposta, che rappresenta il tipo del file, viene calcolato
cercando determinate parole chiave nell'output del comando "file" nel caso Linux.
Nel caso Windows viene letta l'estensione del file: le estensioni riconosciute sono memorizzate nell'array \href{}{extensions},
e l'appartenenza di un'estensione a un tipo di file (testo, immagine...) viene calcolata attraverso delle maschere di bit.
Ogni maschera rappresenta un gruppo di estensioni e ha settati a 1 i bit che corrispondono agli indici degli elementi
dell'array extensions che fanno parte di quel gruppo.\\
Se viene richiesto un file, questo viene mappato in memoria utilizzando la funzione di 
compatibilità \href{}{getFileMap}, che wrappa le rispettive funzioni
mmap di Linux e CreateFileMapping/MapViewOfFile di Windows. Viene poi creato un nuovo thread, che si occupa di
inviare il file mappato in memoria al client, di chiudere la connessione e di costruire una stringa da passare al
logger tramite la funzione \href{}{logTransfer}.

\subsection{Logger}
Il modulo Logger è implementato dall'header logger.h, dal file logger.c e in aggiunta dal file winLogger.c,
utilizzato nel caso in cui si compili su Windows per generare l'eseguibile con il quale avviare il processo.\\
L'header dichiara la struttura logger\_t, utilizzata come interfaccia:
\begin{lstlisting}
    /**
    * A struct representing an instance of a transfer logger
   */
   typedef struct {
       /** Pipe to use for read/write */
       pipe_t logPipe;
       /** Pointer to the mutex guarding the log pipe */
       mutex_t* pLogMutex;
       /** [Linux only] Pointer to the condition variable to notify the logger for incoming data */
       cond_t* pLogCond;
       /** [Windows only] Event to notify the logger for incoming data */
       event_t logEvent;
       /** The pid of the log process */
       proc_id_t pid;
   } logger_t;
\end{lstlisting}
Come nel caso del server, le funzioni comunicano con i rispettivi chiamanti tramite puntatori a 
strutture logger\_t.
L'header espone tre funzioni: per avviare il logger, per interromperlo e per loggare una stringa.
A causa delle differenze tra Windows e Linux circa l'IPC, le due implementazioni sono completamente distinte.

\subsubsection{Linux}
Nel caso Linux, la funzione di avvio startTransferLog inizializza una pipe, un mutex e una condition variable
in uno spazio di memoria condiviso e ne scrive i riferimenti nella struttura logger\_t ricevuta in input.
Dopodiché viene effettuata una fork per avviare il processo che esegua il loop principale.
Il loop principale apre il file di logging e attende sulla condition variable del logger ricevuto in input.
Quando riceve una richiesta di logging (notificata sulla condition variable) acquisisce un lock
esclusivo sul file di logging tramite fcntl e scrive la stringa sul file.
La funzione per interrompere il logger si occupa di liberare tutte le risorse e di inviare SIGINT
al processo.

\subsubsection{Windows}
Il logger di Windows funziona in modo analogo al caso Linux, fatta eccezione per alcune differenze,
(principalmente dovute all'assenza della fork, che consentiva al processo di ereditare i puntatori alle
aree di memoria condivise).
Il mutex e l'evento (che sostituisce la condition variable di Linux) vengono creati con nome, per
potervi poi accedere con facilità dal processo di logging. L'estremo in lettura della pipe viene 
impostato come standard input del processo creato. Il loop principale è demandato a un eseguibile
generato a partire dal file winLogger.c, che opera in modo analogo alla funzione di Linux.\\
Anche in questo caso la funzione di interruzione libera le risorse e termina il processo di logging
mediante la funzione TerminateProcess.

\subsection{Compatibilità}
Il modulo di Compatibilità è implementato dagli header platform.h, datatypes.h, log.h e wingetopt.h, e dai 
sorgenti platform.c e \href{http://note.sonots.com/Comp/CompLang/cpp/getopt.html}{wingetopt.c}.
Offre numerose funzionalità implementate in modo portabile per essere riutilizzate
dai moduli che lo richiedano. Le funzioni si articolano in:
\begin{itemize}
    \item utilità generiche (operazioni sulla working directory, logging...)
    \item operazioni sui socket
    \item operazioni su thread e processi
    \item operazioni sul file system
    \item wrapper per tipi di dato
    \item messaggi di log e debug uniformi
    \item parsing di opzioni da riga di comando.
\end{itemize}
Alcune funzioni notevoli sono:
\begin{itemize}
    \item \href{}{startThread}
    \item \href{}{getFileMap}
    \item \href{}{iterateDir}
\end{itemize}

\subsection{Main}
Le componenti sopra descritte vengono combinate in maniera intuitiva nel main.
Vengono creati i due oggetti server\_t e logger\_t per gestire rispettivamente server e logger.
Dopo aver letto e settato opportunamente le configurazioni, viene eseguita la 
procedura per rendere il processo demone (nel caso Linux). Dopodiché vengono avviati, tramite le apposite 
funzioni, il processo di logging e il server.


\end{document}