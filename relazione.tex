\documentclass{article}

\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{document}

\tableofcontents
%newpage

\section{Utilizzo del software}

\newpage

\section{Struttura del progetto}

Il progetto è strutturato con un approccio modulare gerarchico. 
Ogni modulo esegue uno specifico compito all'interno dell'applicazione, servendosi delle funzionalità
dei livelli inferiori ed esponendo funzionalità ai livelli superiori.
A livello implementativo, a ogni modulo corrisponde uno o più header e uno o più file sorgente.
I quattro moduli sono:
\begin{itemize}
    \item Server - Riceve le richieste di connessione dei client e crea nuovi thread 
    o processi per inviare le risposte. Si occupa inoltre della lettura dei file di configurazione e 
    della gestione dei segnali.
    \item Protocollo - Legge la richieste di un client e costruisce la risposta secondo lo standard del
    protocollo Gopher. In questo modulo avviene la lettura del file system e l'eventuale mapping 
    in memoria dei file.
    \item Logger - Gestisce il processo di logging, che ha il compito di registrare le operazioni di invio
    di file.
    \item Portabilità - API minimale che offre diverse funzioni di supporto portabili. Espone wrapper
    di varie chiamate di sistema e altre operazioni comuni non portabili, nonché wrapper di tipi di dato.
\end{itemize} 
Di seguito vengono esaminati in astratto i moduli nel dettaglio.

\subsection{Server}
Il modulo Server si occupa di leggere il file di configurazione, di inizializzare la Winsock DLL 
(caso Windows), di amministrare le connessioni tramite socket e di gestire i 
segnali per l'interazione con l'utente.
Quando riceve una richiesta di connessione, il modulo si occupa di generare un nuovo thread o un nuovo processo
e passare il socket connesso al modulo Protocollo.
Il modulo Server espone un'interfaccia composta da una struttura dati (server\_t) e
varie funzioni per inizializzare il socket, leggere le configurazioni, installare i 
gestori di segnali di default e mettere in ascolto il server.  

\subsection{Protocollo}
Il modulo Protocollo riceve in input un socket connesso.
Esso si occupa di leggere, validare, interpretare e soddisfare la richiesta del client.
Nel caso in cui venga inviato un file, il modulo Protocollo richiede al modulo Logger di registrare 
l'avvenuto trasferimento.

\subsection{Logger}
Il modulo Logger si interfaccia con i moduli superiori attraverso una struttura dati (logger\_t) che
contiene le informazioni sul processo di logging, e le funzioni per avviare o interrompere il processo
e loggare un trasferimento.
E' implementato dall'header logger.h e dal file logger.c, nonché dal file winLogger.c nel caso di Windows. 


\subsection{Portabilità}
Il modulo portabilità offre numerose funzionalità implementate in modo portabile per essere riutilizzate
dai moduli che lo richiedano. Le funzioni si articolano in:
\begin{itemize}
    \item utilità generiche (operazioni sulla working directory, logging...)
    \item operazioni sui socket
    \item operazioni su thread e processi
    \item operazioni sul file system
    \item wrapper per tipi di dato
    \item messaggi di log e debug uniformi
    \item parsing di opzioni da riga di comando.
\end{itemize}
Il modulo Portabilità è implementato dagli header platform.h, datatypes.h, log.h e wingetopt.h, e dai 
sorgenti platform.c e \href{http://note.sonots.com/Comp/CompLang/cpp/getopt.html}{wingetopt.c}. 
\newpage


\section{Scelte implementative}

Per quanto il progetto sia stato impostato con una struttura modulare per trarre tutti i vantaggi della
separation of concerns in fase di sviluppo, le sue componenti sono comunque interconnesse e progettate per coesistere 
in un'unica applicazione. Da qui la scelta di rendere globali diverse costanti di configurazione 
e di usare path relativi che assumono la struttura di file e directory.\\

Per realizzare l'aspetto modulare ogni file espone, tramite il proprio header, funzioni utili a espletare
i compiti previsti dal modulo a cui il file fa riferimento (logicamente, poiché non c'è nessuna organizzazione
che rifletta la suddivisione dei moduli a livello di directory). Le funzioni di ogni modulo
utilizzano come valore di ritorno delle costanti per indicare il successo o il fallimento dell'operazione (a volte
messe in OR con altre costanti per fornire ulteriori informazioni sull'esito).
\\Le funzioni esposte utilizzano i tipi definiti in datatypes.h, per astrarre dai tipi specifici utilizzati
dalla libreria Win32 o dalle funzioni POSIX. La realizzazione interna delle funzioni invece
 utilizza i tipi specifici della piattaforma, e consiste, laddove impossibile scrivere codice portabile o utilizzare solo funzioni offerte da Portabilità,
 di un'implementazione ad hoc per Windows e una per GNU/Linux, demandando la scelta dell'implementazione
da utilizzare al preprocessore tramite la direttiva 
\begin{lstlisting} 
#if defined(_WIN32) 
\end{lstlisting}
Una documentazione approfondita su ogni file, funzione e struttura, generata con Doxygen a partire dalla 
documentazione sul codice sorgente, è disponibile \href{html/index.html}{qui}. 

\subsection{Server}
Il modulo Server è implementato dall'header server.h, dal file server.c e dal file winGopherProcess.c 
nel caso in cui si compili su Windows.\\
L'header dichiara la struttura server\_t, utilizzata come interfaccia per il modulo:
\begin{lstlisting}
/** A struct representing an instance of a gopher server */
typedef struct {
    /** The socket of the server */
    socket_t sock;
    /** The socket address */
    struct sockaddr_in sockAddr;
    /** The port where the server is listening */
    unsigned short port;
    /** A flag indicating whether the server should spawn a process or a thread per request */
    bool multiProcess;
} server_t;
\end{lstlisting}
La maggior parte delle funzioni dichiarate dall'header richiede in input
un puntatore a una struttura server\_t, dalla quale leggere o sulla quale scrivere informazioni.

\subsubsection{Lettura della configurazione}

La lettura dei file di configurazione avviene tramite la funzione \href{html/server_8c.html#a2e07cc3959eab913ab4c894bc6c8395d}
{readConfig}, che legge (usando le funzioni della libreria standard) il file identificato 
dal path \href{html/globals_8h_source.html}{CONFIG\_FILE} e scrive le configurazioni nella struttura server\_t ricevuta in input.
Il file è una sequenze di righe del tipo CHIAVE=VALORE.
La funzione readConfig() viene chiamata nel main all'avvio dell'applicazione, e ogniqualvolta
venga ricevuto il segnale SIGHUP (caso Linux) o CTRL\_BREAK (caso Windows) durante il \href{html/server_8h.html#a533c9a4292e9d1106ff7c54fbf75090a}
{main loop} del server.\\
I gestori dei segnali utilizzano le variabili booleane globali
\begin{lstlisting}
    static sig_atomic volatile updateConfig = false;
    static sig_atomic volatile requestShutdown = false;
\end{lstlisting}
che vengono lette periodicamente nel loop del server. L'accesso a queste variabili è protetto da una 
CRITICAL\_SECTION nel caso Windows e dall'uso del tipo sig\_atomic\_t (wrappato in sig\_atomic per comodità)
nel caso Linux, che assicura l'accesso atomico alla variabile anche in presenza di interrupt asincroni.
Nel caso in cui la lettura delle configurazioni fallisse, la funzione \href{html/server_8h.html#a2cda6ac8456a82040d05596906d66acc}{defaultConfig}
legge le impostazioni di default, salvate in globals.h.

\subsubsection{Preparazione del socket}

La funzione \href{html/server_8h.html#a4c40ae864a752c34a4f237a9445db202}{prepareSocket} si occupa
di inizializzare un socket e metterlo in stato di listening.\\
Quando è richiesto un cambio nel numero di porta, la funzione viene chiamata con il flag SERVER\_UPDATE,
che chiude il socket su cui era in ascolto in server e ne inizializza uno nuovo.

\subsubsection{Avvio del server}

Il server viene avviato con la funzione \href{html/server_8h.html#a533c9a4292e9d1106ff7c54fbf75090a}{runServer},
che prende in input un puntatore a una struttura server\_t inizializzata con le funzioni precedenti.
La funzione attende con una select una richiesta di connessione, controllando periodicamente la ricezione
di segnali. Questa scelta è motivata dal fatto che i segnali da console di Windows non interrompono la select.
Quando il server riceve una richiesta di connessione, genera un nuovo thread o processo a seconda della (modalità
utilizzata), il quale esegue il protocollo tramite la funzione \href{html/protocol_8h.html#a733e68cc8d5f947c30d0ca51e1b76d9b}{gopher}.
Quando il server riceve un segnale SIGINT, la funzione runServer ritorna SERVER\_SUCCESS. Il modulo Server
non si occupa di liberare le risorse.

\section{Protocollo}
Il modulo Protocollo è implementato dall'header protocol.h e dal file protocol.c.
L'header espone all'esterno, oltre a diverse costanti, una singola funzione \href{html/protocol_8h.html#a733e68cc8d5f947c30d0ca51e1b76d9b}{gopher}.
La funzione legge l'input dal socket ricevuto fin quando non legge un CRLF, come da protocollo.
Se la connessione viene chiusa o si verifica un errore, la funzione ritorna GOPHER\_FAILURE.
L'input letto viene poi validato (poiché il selettore viene utilizzato per recuperare la risorsa
richiesta, non può contenere costrutti per la navigazione di directory, quali ./ ../ etc) e normalizzato
(il selettore deve contenere solo forward slash e non backslash, e non può terminare con uno o più slash).


\end{document}